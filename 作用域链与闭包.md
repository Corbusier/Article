# 作用域链与闭包总结

---
##1.执行上下文
函数的每次调用都有与之相关的作用域和执行上下文。从根本上来说，作用域是基于函数的，而上下文是基于对象的。作用域涉及到被调用函数中的变量访问，并且不同的调用场景是不同的。上下文始终是this关键词的值，它是拥有(控制)当前所执行代码的对象的引用。一旦上下文执行完毕，它将被栈顶弹出，并将控制权返回给之后的上下文，直到只剩全局上下文为止。

关于执行栈：

 - 单线程。
 - 同步执行。
 - 一个全局上下文。
 - 无限制函数上下文。
 - 每次函数被调用创建新的执行上下文，包括调用自己。

###执行上下文的细节
函数每次被调用都会创建新的执行上下文。在JS解释器的内部，调用执行上下文，分为两个阶段：

 1. 创建阶段
    - 创建作用域链(Scope Chain)
    - 创建变量，函数和参数
    - 为"this"赋值
 2. 激活/代码执行阶段：
    - 指派变量的值和函数的引用，解释/执行代码

可以将每个执行上下文抽象为一个对象并有三个属性：
```
    executionCotext = {
        scopeChain : { //变量对象 + 所有父执行上下文的变量对象 },
        variableObj : {//函数 参数,内部变量和函数声明},
        this : {...}
    }
```
示例：
```
    function fn(n){
        var a = "hello";
        var b = function private(){
            
        };
        function c(){
            
        }
    }
    fn(29);
```
当调用fn(29时),执行上下文的创建状态如此：
```
    fnExecutionContext = {
        scopeChain : {...},
        variableObj : {
            arguments : {
                0 : 29,
                length : 1
            },
            n : 29,
            c : pointer to function c(),
            a : undefined,
            b : undefined
        },
        this : {...}
    }
```
创建阶段只会处理定义属性的名字，并不会赋值。一旦创建阶段结束，执行流进入函数并执行代码，这时就会为变量对象赋值。
###关于变量、函数声明提升

 1. 为什么能在fn声明之前访问它？
    - 在执行上下文的创建阶段时，变量赋值在代码执行阶段才会被赋值，而函数开始执行前，fn已经在活动对象之中被定义了，因此是可以访问到的。

2.在如下的代码中foo被声明了两次，为什么foo显示为函数而不是undefined或字符串？
```
    (function() {
        console.log(typeof foo); // 函数指针
        console.log(typeof bar); // undefined
    
        var foo = 'hello',
            bar = function() {
                return 'world';
            };
        function foo() {
            return 'hello';
        }
    }());
```

 - 尽管foo声明了两次,但是在创建阶段函数已经在活动对象中被创建，这个过程先于变量创建。
 - 当解释到var foo时，foo属性名已经存在，因此代码不会做任何的修改并继续执行。

##2.作用域
JS代码的执行过程中分为两个阶段，代码编译阶段和代码执行阶段。前者由编译器完成，将代码翻译成可执行的代码，词法作用域会被确定。执行阶段由引擎完成，主要任务是执行可执行的代码，执行上下文在这个阶段被创建。

编译阶段：

     - 词法分析
     - 语法分析
     - 可执行代码生成
     - 词法作用域确定

执行阶段：

     - 执行上下文创建
     - 代码执行
     - 垃圾回收
    
    
##3.作用域链
如执行上下文描述，在这个过程中会创建作用域链。作用域链可以看做是作用域规则的具体实现。
    
        作用域链是由当前环境和上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。

示例：
```
    var a = 20;
    
    function test(){
        var b = a + 10;
        function innerTest(){
            var c = 10;
            return b + c;
        }
        return innerTest();
    }
    rest();
```
在这个例子中，全局变量，函数test，函数innerTest的执行上下文先后创建。他们的变量对象分别为VO(global)，VO(test)，VO(innerTest)。而innerTest的作用域链则同时包含了三个变量对象。
```
    innerTestExecutionObj = {
        scopeChain ： [VO(innerTest),VO(test),VO(global)],
        variableObj : {c,b},//变量对象
        this : {...}
    }
```
在作用域链的前端是函数内部的变量对象，而最后一项是全局变量对象。

##4.闭包
假设函数A内部定义了函数B,当函数B执行时,访问了A内部的变量对象,那么A就是一个闭包。闭包可以找到并访问其所在的作用域。
  
当函数的上下执行文在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间就会被垃圾回收器释放，但是闭包会阻止这一过程。      

例如：
```
    var fn = null;
    function foo(){
        var a = 2 ;
        function inner(){
            console.log(a);
        }
        fn = inner;
    }
    function bar(){
        fn();
    }
    
    foo();
    bar();//2
```
当foo执行完成之后应该会被回收,但是在其内部，全局变量fn保留了对inner的引用,因此在fn在bar内部执行时才可以访问这个被保留下来的变量对象,所以仍然能够访问到a。

所以foo就称为闭包。在闭包中能访问到的变量，仍然是作用域链上能查询到的变量。

##5.应用场景

 - 模块
```
    (function () {
        var a = 10;
        var b = 20;
    
        function add(num1, num2) {
            var num1 = !!num1 ? num1 : a;
            var num2 = !!num2 ? num2 : b;
            return num1 + num2;
        }
    
        window.add = add;
    })();
    add(10, 20);
```
add是这个模块对外暴露的一个公共方法。而a，b被作为私有变量。

关于私有变量，私有函数，也可以通过闭包访问。
```
    function Out(){
        var Private = 10;
        function PrivateFn(){
            return false;
        }
        this.inside = function(){
            console.log(++Private);
            return PrivateFn();
        }
    }
    
    var son = new Out();
    console.log(son.inside());
```

在这个例子中,在构造函数上定义的特权方法(可以访问构造函数的私有变量和私有函数的公共接口),只能通过实例化构造函数后,使用inside()方法访问私有变量、函数,除此之外没有别的方法。不过通过构造函数的方法也有一些弊端,因为只能使用构造函数实例化访问,所以也会面临不同的实例化对象上的同名函数不同,标识符重解析,不同的作用域,不利于代码复用等问题。

