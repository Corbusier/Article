# 引用类型 

    Object类型 Array类型 Data类型 RegExp类型 Function类型 基本包装类型 单体内置对象

---


##1.Object类型
创建Object实例的方式有两种,第一个是使用new操作符跟Object构造函数。如下：
```
    var person = new Object();
    person.name = "Nicholas";
    person.age = 25;
```
第二种是对象字面量的方式。
```
    var person = {
        name : "Nicholas",
        age : 25
    };
```
属性名也可以是字符串形式。
一般来讲访问属性名都是点表示法,通过[]表示法能得到的范围更大,它可以通过变量来访问属性。例如：
```
    var propertyName = "name";
    alert(person[propertyName]);//"Nicholas"
```
如果属性名中包含会导致语法错误的字符,或者属性名使用的是关键字或保留字,也可以通过方括号表示法获取。例如：
```
    person["first name"] = "Nicholas";
```
由于属性中包含一个空格,所以不能使用.表示法。但是属性名是可以包含非字母非数字的,这时候就需要方括号表示法。

##2.Array类型
数组的每一项都可以保存任何类型的数据,而且数组的大小是可以动态调整的,可以随着数据的动态添加自动增长。
创建数组的方式也是两种,第一种使用Array构造函数。
```
    var arr = new Array();
```
可以省略new操作符。给构造函数传递参数,如果传递的是数值,得到的是包含指定项数的数组,如果传递的是其他类型的参数,就会创建包含参数值的数组。

第二种是使用字面量的方式：
```
    var colors = ["red","blue","green"];
    var arr = [1,2,];
    var options = [,,,,,];
```
不要使用后两种方式,因为在标准浏览器下,不会为最后一个,后增加数据。而在IE8之前的版本中会填充一个undefined在此。

在读取和设置数组的值时,要使用方括号并提供响应值的索引。
```
    var colors = ["red","blue"];
    colors[1] = "black";
    colors[2] = "brown";
    colors[10] = "green";
    alert(colors.length);//11
```
如此就可以设置对应项的值,并且实时得更改数组的长度。
数组的长度并不是只读的,设置这个属性可以从数组的末尾移除项或向数组添加新项。如果将length属性设置为大于数组项数的值,则新增的每一项都会取得undefined值。同时也可以在最后一项之后添加数组项,例如：
```
    colors[colors.length] = "pink";
    colors[colors.length] = "gold";
```
数组最多可以包含4,294,967,295个项。

###1.检测数组
对于检测数组类型,instanceof 不一定准确。因为可能在别的框架中包含的是不同的全局执行环境,那么就存在两个以上不同版本的Array构造函数。因此可以使用Array.isArray方法。它可以直接确定是不是数组,不管是在哪个全局执行环境创造的。

###2.转换方法
所有对象都具有toLocalString、toSring、valueOf方法。

 - 调用toString方法返回的是数组中的每个值的字符串拼接而成,并由,分割的字符串。
 - 调用valueOf方法返回的是原数组。
 - 调用toLocalString返回的经常与toString的返回值相同。但是也有特例。
 
对一个对象使用alert,默认的在后台使用toString方法,这与显式调用toString结果一样。而如果显式的调用toLocalString,则对每一项都要使用toLocalString方法。
```
    var person1 = {
        toLocaleString : function(){
            return "nicholas";
        },
        toString : function(){
            return "Nicholas";
        }
    }
    var person2 = {
        toLocaleString : function(){
            return "Grigorios";
        },
        toString : function(){
            return "Greg";
        }
    }   
    var people = [person1,person2];
    alert(people);
    alert(people.toString());
    alert(people.toLocaleString());
```

数组继承的这三种方法,在默认情况下,都会以,作为分隔符返回数组项。而join方法可以指定以什么样的分隔符返回数组项。如果不传参数或参数为undefined,则以默认的,分隔数组项,传递的参数为分隔符的字符串形式。
```
    var colors = ["red","blue","green"];
    console.log(colors.join(undefined));
    console.log(colors.join("||"));
```

    如果数组中的某一项为null或undefined,那么该值在join()/toLocaleString()/toString()/valueOf()方法返回的结果都以空字符串表示。
    
###3.栈方法
栈方法为后入先出,分别有push和pop方法。push进数组的最后一项,可以添加任意多个项进入数组的末尾,并返回新的长度值。pop删除最后一项,并返回被删除项。

###4.队列方法
队列方法为后入后出,分别有shift()和unshift()。shift方法为删除数组的第一项,并返回这一项。unshift()添加到头部任意多项,并返回新的长度值。

###5.重排序方法
reverse()及sort()方法。reverse()可以将数组项的顺序反转,而sort()只是将传入的参数按照字符串的顺序来排序,也就是说这个排序不一定正确,按照的规则一般不是从小到大。所以要给sort()传入一个比较函数作为参数,进行正确的比较。
```
    var value = [0,2,4,19,5];
    value.sort(compare);
    function compare(value1,value2){
        if(value1 < value2){
            return -1;
        }else if(value1 > value2){
            return 1;
        }else{
            return 0;
        }
    }
    alert(value);
```
对于数值类型或valueOf方法会返回数值类型的对象,可以使用更简易的比较函数：
```
    function compare(value1,value2){
        return value1 - value2;
    }
```
因为对函数对象运行 + - 运算符时,会按照valueOf=>toString调用对象上的方法。

###6.操作方法
concat()方法可以基于当前数组中的所有项创建一个副本,然后将接收到的参数添加到数组之后,形成新的数组,返回的就是这个新的数组。而原数组内容保持不变。

slice()方法能够基于当前数组的一项或者多项创建一个新数组。可以接收一个或两个参数,只有一个参数则表示从该位置开始到末尾,两个参数表示从该位置开始到下一位置,但不包含结束位置。
        
        slice()方法不会影响原数组。
```
    var colors = ["yellow","grenn","purple","pink"];
    var colors1 = colors.slice(1);
    var colors2 = colors.slice(1,3);
    alert(colors1);
    alert(colors2);
```
如果参数中包含负数,直接加上数组长度,得到的数就是对应的位置。如：
```
    //包含5项的数组
    slice(-2,-1);
    slice(3,4);
```
如果起始位置大于终止位置,则返回空数组。

splice()方法主要用途是向数组中部插入项,使用这个方法的方式有如下三种：

 - **删除**：如果传入两个参数。起始位置和要删除的项数。如splice(0,2)会删除数组中的前两项内容。
 - **插入**：如果传入三个参数。起始位置,要删除的项数,插入任意多项。
 - **替换**：同样是三个参数。插入的项数不一定与删除项数相同。如splice(2,1,"red","green")就会删除位置2开始的一项,然后插入"red","green"。
 
splice方法可以返回从原数组中被删除项。而原数组则随着该方法改变。
```
    var name = ["Curry","KaKa","Ronaldo","Messi"];
    var removed = name.splice(2,1);
    
    console.log(name);//["Curry", "KaKa", "Messi"]
    console.log(removed);//["Ronaldo"]
    
    removed = name.splice(1,0,"Nesta","Inzagi");
    console.log(name);["Curry", "Nesta", "Inzagi", "KaKa", "Messi"]
    console.log(removed);[]
    
    removed = name.splice(1,2,"CR","NeyMal");
    console.log(name);["Curry", "CR", "NeyMal", "KaKa", "Messi"]
    console.log(removed);["Nesta", "Inzagi"]
```

###7.位置方法
indexof()及lastIndexOf()可以接收两个参数,第一位是必选的,表示搜索项,第二位是查找起点位置的索引。如果查找不到则返回-1,在查找的过程中,使用的是全等操作符,必须严格相等。lastIndexOf()则是从后往前找。

###8.迭代方法

 - every()。对数组中的每一项运行给定函数,每一项都返回true才会返回true。
 - filter()。对数组中的每一项进行过滤,符合条件的组成新数组。
 - forEach()。相当于for循环。
 - map()。对数组中的每一项运行给定的函数,返回每次函数调用的结果组成的数组。
 - some()。对数组的每一项运行给定函数,只要有一个返回true,则最终返回true。
 
        以上方法均不会修改原数组的值。

```
    var nums = [1,2,3,4,77,29,2];
    var res = nums.every(function(item){
        return (item > 9)
    })
    alert(res);//false

    res = nums.filter(function(item){
        return (item <9);
    })
    alert(res);//1,2,3,4,2

    res = nums.some(function(item){
        return (item>70)
    })
    alert(res);//true

    res = nums.map(function(item,index){
        return (item*2 + index)
    })
    alert(res);//2,5,8,11,158,63,10

    res = nums.forEach(function(item,index,array){
        //执行某些操作
    })
```

###9.归并方法
reduce()和reduceRight()这两个方法都会迭代数组中的所有项,然后构建一个最终返回的值。两种方法都接收两个参数,一个在每项上调用的函数和作为归并基础的初始值(可选)。调用函数接收四个参数值,前一个值,当前值,项的索引,以及数组对象。
```
    var nums = [1,2,3,4,77,29,2];
    var res = nums.reduce(function(prv,cur,array){
        return prv + cur;
    }) 
    console.log(res);//118
```
这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上,因此第一个参数是数组的第一项,第二个参数有就是数组的第二项。

##3.Date类型
使用的是自1970年1月1日午夜零时以来经过的毫秒数来保存日期。创建一个日期对象,如下所示：
```
    var now = new Date();
```
不传递参数的前提下,自动获得当前时间和日期。如果要获得指定的日期和时间,必需传入换算后的毫秒数,为此提供了Date.parse()和Date.UTC()。

当输入的格式为月/日期/年时,直接在后台调用的的是Date.parse(),当输入的是年/月/日/具体数值时,采用的是Date.UTC方法,但是月份会基于0开始,所以0表示1月,并且采用24小时计时法。

ES5提供了Date.now()方法,返回的是调用这个方法时的时间毫秒数,简化了Date对象分析代码的工作：
```
    var start = Date.now();
    dosomeThing();
    var stop = Date.now();
    result = stop - start;
```
支持该方法的都是现代浏览器,如果在不支持的浏览器上使用该方法,可以使用+操作符获取Date对象的时间戳。如下：
```
    var start = +new Date();
    dosomeThing();
    var stop = +new Date();
    result = stop - start;
```
###1.继承的方法
```
    var now = new Date();
    console.log(now.toString());//Wed Mar 15 2017 21:55:50 GMT+0800 (中国标准时间)
    console.log(now.toLocaleString());//2017/3/15 下午9:55:50
    console.log(now.valueOf());//1489586150352
```
对于Date类型的继承方法,toLocalString和toString返回的结果只是在格式上有所不同,并没有什么价值。而valueOf的方法则直接返回时间戳。

##4.RegExp类型
正则表达式其中的模式(pattern)可以是任何简单或复杂的正则表达式,可以包含字符类、分组、反向引用、向前查找、限定符。每个正则表达式都可以带有一个或多个标志。用以标明正则表达式的行为。支持下列三个标志：

 - g：表示全局模式,用于所有字符串,而非在发现第一个匹配项时立即停止。
 - i：忽略大小写。
 - m：表示多行模式。到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
 
```
    //匹配字符串中所有at的实例
    var pattern1 = /at/g;
    //忽略大小写匹配字符串中的第一个"bat"或"cat"
    var pattern2 = /[bc]at/i;
    //忽略大小写匹配全局以at结尾的三个字符的组合
    var pattern3 = /.at/gi;
```
模式中使用的所有元字符都必须经过转义。包括：
```
    ( [ { \ ^ $ | ) ? * + . ] }
```
这些元字符在正则表达式中都有一或多个用途,因此如果想要匹配字符串包含的这些字符,就必须对他们进行转义。例如在之前的例子中：
```
    var pattern2 = /\[bc\]at/i;
    var pattern3 = /\.at/gi;
```
    
    也就是在转义字符前加上\
另一种创建正则表达式的方式是使用RegExp构造函数接受两个参数,一个是要匹配的字符串模式,另一个是可选的标志字符串，可以使用字面量定义的RegExp,都可以使用构造函数来定义。
```
    var pattern2 = /[bc]at/i;
    //改为构造函数形式
    var pattern3 = new RegExp("[bc]at","i");
```
传递给构造函数的参数都是字符串,所以在某些情况下需要双重转义。比如：
```
    /\[bc\]at/      \\[bc\\]at
    /\.at/          \\.at
    /name\/age/     name\\/age
    /\d.\d{1,2}/    \\d.\\{1,2}
    /\w\\hello\\123/  \\w\\\\hello\\\\123
```
###1.RegExp实例方法
    
    RegExp对象的主要方法是exec(),接收一个参数,即被检测的字符串,然后返回的是包含第一个匹配项信息的数组,如果没有则返回null。返回的是Array实例,但是包含两个额外的属性,index和input。其中index表示匹配项在字符串中的位置,而input则表示应用正则表达式的字符串(检测字符串本身)。
```
    var text = "mom and dad and baby";
    var pattern = /mom( and dad( and baby)?)?/gi;
    var matches = pattern.exec(text);
    console.log(matches.input);
    console.log(matches[0]);
    console.log(matches[1]);
    console.log(matches[2]);
```
以上的例子中,input为整个字符串,而该模式下包含了两个捕获组,内部的捕获组" and baby",包含它的捕获组匹配" and dad"或" and dad and baby";所以数组中的第一项是匹配的整个数组,第二项是第一个捕获组内容,第三项是第二个捕获组内容。

对于exec()方法,即使在模式中设置了全局标志(g)。每次也只能返回一个匹配项。在不设置g的前提下,会一直返回第一个匹配项的信息。如果设置g,则每次都会在字符串中继续查找新匹配项。
```
        var text = "cat, bat, saat, fat";
        var pattern = /.at/g;

        var matches = pattern.exec(text);
        console.log(matches.index);0
        console.log(matches.input);cat, bat, saat, fat
        console.log(pattern.lastIndex);3

        matches = pattern.exec(text);
        console.log(matches.index);5
        console.log(matches.input);cat, bat, saat, fat
        console.log(pattern.lastIndex);8

        matches = pattern.exec(text);
        console.log(matches.index);11
        console.log(matches.input);cat, bat, saat, fat
        console.log(pattern.lastIndex);14

        matches = pattern.exec(text);
        console.log(matches.index);16
        console.log(matches.input);cat, bat, saat, fat
        console.log(pattern.lastIndex);19
```

第二种方法是test,它接受字符串参数,当被检测项与模式匹配时返回true,否则为false。如果目的只是为了检测是否有效,验证用户输入的情况下适用。
```
    var text = "000-00-0000";
    var pattern = /\d{3}-\d{2}-\d{4}/;
    if(pattern.test(text)){
        alert("The pattern was matched");
    }
```
该表达式可以检测数字输入,当为XXX-XX-XXXX数字时,则表示通过匹配。

##5.Function类型
函数通常是使用声明定义的,也可以使用函数表达式定义。通过变量名访问函数亦可。还有一种可能是使用new Function构造函数创建,但是会导致解析两次代码,第一次解析常规代码,第二次解析传入构造函数中的字符串,从而影响性能。
```
    var sum = new Function("num1","num2","return num1 + num2");//不推荐
```
函数名仅仅是一个指针,因此函数名与其它包含对象指针的变量没有区别。在复制变量时,如果切断了一个指针的指向,不会影响复制变量的正确指向。
```
    var obj1 = new Object();
    obj1.name = "Nicholas";
    obj1.age = "age";
    obj1.sayName = function(){
        alert(this.name);
    }
    var obj2 = obj1,
    obj1 = null;
    obj2.sayName();//"Nicholas"
```
同理可以证明,在函数(函数也是对象)中,更改了指针并不会造成引用变化。
```
    function sum(num1,num2){
        return num1 + num2;
    }
    alert(sum(10,10));//20
    var other = sum;
    sum = null;
    alert(other(10,20));//30
```
###1.没有重载(深入理解)
函数名为一个指针,所以后声明的函数会覆盖同名的函数。

###2.函数声明和函数表达式
解析器会先读取函数声明,并使其在执行代码之前可用。至于函数表达式并无这个函数声明提升的过程,因此必须等解析到所在的代码行,才可以被解释执行。
```
    alert(sum(29,9));//可用
    function sum(num1,num2){
        return num1 + num2;
    }
    
    alert(sum(29,9));//不可用
    var sum = function(num1,num2){
        return num1 + num2;
    }
```
在第二段中,在函数读取到函数所在的语句前,sum不会保存对函数的引用,所以无法正确的执行函数。

###3.作为值的函数
函数名本身是一个变量,因此函数也可以作为值来使用。所以可以将一个函数像传递参数一样传递给另一个函数,也可以用一个函数返回另一个函数。
```
    function add(num){
        return num + 20;
    }
    var result = callSome(add,10);
    function callSome(Fun,someArguments){
        return Fun(someArguments);
    }
    alert(result);//30
```

函数不仅可作为函数的参数,还可以从一个函数中返回另一个函数。

比如要通过sort函数根据一个对象数组中的某个属性进行排序,就可以通过定义一个函数来解决。
```
    var data = [
    {
        "name" : "Zachary",
        "age"  : "28"
    },  
    {
        name : "Nicholas",
        age  :  30
    }]
    function Compare(propertyName){
        return function(obj1,obj2){
            var value1 = obj1[propertyName];
            var value2 = obj2[propertyName];
            
            if(value1 < value2){
                return -1;
            }else if(value1 > value2){
                return 1;
            }else{
                return 0;
            }
        }
    }
    data.sort(Compare("name"));//此处按照变量名称字符串比较
    alert(data[0].name)//Nicholas
    
    data.sort(Compare("age"));//此处按照变量名称字符串比较
    alert(data[0].name)//Zachary
```

###4.函数内部属性
函数内部有两个特殊的对象,arguments和this。arguments对象是一个类数组,包含着函数的参数列表,在其中还有一个callee属性,用于保存拥有这个参数列表的函数。
使用这个callee属性,可以在递归函数中,解除与函数紧密的耦合。
```
    function factorial(num){
        if(num < 1){
            return 1;
        }else{
            return num * arguments.callee(num-1);
        }
    }
    factorial(4);
```
this对象保存的是当前执行环境对象。例如全局作用域中调用函数,那么this指向的就是window对象。

ES5还定义了一个函数属性：caller。它保留的是引用该函数的函数的代码。如果在全局作用域下调用当前函数,它的值为null。
```
    function outer(){
        inner();
    }
    function inner(){
        alert(inner.caller);
    }
    outer();
```
返回的则是outer函数的代码,在严格模式下,访问callee和caller都会造成错误。严格模式下,还不能为caller属性赋值。

###5.函数属性和方法
函数是对象,所以函数也有属性和方法。每个函数都有的两个属性：length和prototype。其中length为函数接收的命名参数的个数。对于引用对象而言,所有的实例方法都保存在prototype上,比如valueOf、toString等,在ES5中,prototype是不可枚举的。

    每个函数都包含两个非继承而来的方法,apply和call。这两种方法都是在特定的作用域中调用函数,实际上等于设置函数体内的this值。接收的第一个参数都是this值,第二个参数可以是Array实例,也可以是arguments(只要有length属性均可)。区别在于call需要逐一列出参数,apply可以使用arguments。

真正的用处在于call和apply能够扩充函数的作用域。例如：
```
    window.color = "red";
    var o = {color : "blue"};
    sayColor.call(o);//blue
    function sayColor(){
        alert(this.color);
    }
```
使用bind更改this的指向,不会立即执行这个结果。因此需要将这个对象保存在变量中,再由变量执行。

##6.基本包装类型
有三个特殊的引用类型,Boolean、Number和String。在读取一个基本类型值的时候,后台都会创建对应的基本包装类型的对象,从而可以调用一些方法来操作数据。例如：
```
    var str = "come baby";
    var tes = str.substr(2,1);//m
```
基本类型值不应该具有方法,但是却又可以调用方法,其实是后台自动完成的处理：

 1. 创建String类型的一个实例；
 2. 在实例上调用指定的方法；
 3. 销毁实例
 
因此这三个特殊的引用类型都可以使用方法了,而基本包装类型与引用类型的主要区别就是对象的生存期。引用类型创建的对象,在之上添加的属性和方法在执行流离开当前作用域之前都一直保存在内存中。而基本包装类型的对象,只存在于到吗执行的瞬间,随即被销毁。因此在运行时添加的方法属性都是无效的。
```
    var str = "s";
    str.color = "red";
    alert(str.color);//undefined
```
###1.Boolean类型
可以使用Boolean构造函数创建一个Boolean对象,它是Boolean的一个实例,并不是布尔值。尽量不要使用这个Boolean对象。

###2.Number类型
可以为数字基本类型值的toString()方法传递一个表示技术的参数,告诉它返回几进制数值的字符串形式。

此外还提供了几种关于数值格式化为字符串的方法。toFixed方法可以按照指定的小数位返回数值的字符串表示。
```
    var num = 10;
    alert(num.toFixed(2));"10.00"
```
**toFixed**还可以舍入,比如：
```
    var num = 10.005;
    alert(num.toFixed(2));//10.01
```
不同的浏览器的舍入规则不同,例如传入0时,IE8之前的版本不能正确的舍入{(-0.94,-0.5],[0.5,0.94)}之间的值。对于这个范围内的值,IE会返回0,而不是-1或1。

**toExponential()**,可以返回以指数表示法表示的数值的字符串形式。参数依然可以表示小数位数。
```
    var sum = 35201040;
    console.log(sum.toExponential(2));//3.52e+7
```
**toPrecision( )**方法可以按照整数形式,也可以返回指数形式的数值字符串。具体规则是看哪种规则合适。
```
    var sum = 20392;
    console.log(sum.toPrecision(1));2e+4
    console.log(sum.toPrecision(2));2.0e+4
    console.log(sum.toPrecision(3));2.04e+4
```
同样也可以显式的创建Boolean对象,但是并不建议这么做。这样会识别的混淆。

###3.String类型
####1.字符方法
charCodeAt()和charAt()方法用于访问字符串中特定字符的方法。这两个方法都接收一个参数,基于0的字符位置。都只能获取到单个字符的字符串形式。charAt()返回的是字符,charCodeAt()返回的是字符编码。

####2.字符串操作方法
concat().用于拼接字符串得到新的字符串。
还有slice、substr和substring方法。
slice()有一个或两个参数,用于截取字符串,不包括截止位置,当有负数能将负数加上长度使用。
substr()有一个或两个参数,第二个参数表示截取的长度,长度不可小于0,第一个参数可以为负数,转换后使用。
substring()可以有一个或两个参数,并且还可以交换位置,按照参数从小到大的顺序截取字符串。

####3.字符串位置方法
indexOf()和lastIndexOf()按照指定的位置从前往后截取字符串。
```
    var str = "adddkabkkdiuabl";
    var res = [];
    for(var i = 0;i<str.length;i++){
        if(str.indexOf("ab",i) != -1){
            res.push(str.indexOf("ab",i));
            i = str.indexOf("ab",i);
        }
    }
    console.log(res);//5,12
```

####4.trim方法
去除字符串前置和后缀的空格,返回的是字符串的副本,原始字符串的并不会改变。

####5.字符串大小写转换
toUpperCase()、toLowerCase()。

####6.字符串的模式匹配方法
第一个方法是match()。

    接收一个参数,即RegExp对象或正则表达式,这一点与RegExp正好相反,切记！调用方法的是匹配项字符串。
```
    var str = "bat,cat,sat,fat";
    var pattern = /.at/g;
    var matches = str.match(pattern);
    //pattern.exec(str);
    alert(matches[0]);bat
    alert(matches[1]);cat
    alert(matches[2]);sat
    alert(matches[3]);fat
```
第二个方法是search()。
    
    唯一的参数与match参数一样,由字符串或RegExp对象指定的一个正则表达式。该方法返回的是字符串第一个匹配项的索引。如果没有匹配项则返回-1。仅仅只能返回一次,比indexOf稍微强一点的地方就是可以使用正则作为参数,且只能有一个参数,其他没有区别。

为了简化替换字符串的操作,提供了replace方法。
这个方法接收两个参数,第一个参数可以是正则或字符串,第二个可以是字符串或函数。
```
    var str = "bat,cat,sat,fat";
    var res = str.replace(/at/g,"ond");
    alert(res);//bond,cond,sond,fond
```

第二个参数也可以是一个函数。函数内包含三个参数,分别为模式的匹配项,匹配项的索引值,原始字符串。如果匹配的是多个捕获组,那么第一个参数就包含了第一个捕获组的匹配项,第二个...第n个捕获组的匹配项。这个函数应该返回一个字符串,用于替换匹配项。
```
    function Escape(text){
            return text.replace(/[<>"&]/g,function(matches,pos,orginalStr){
                switch(matches){
                    case "<":
                        return "&lt;";
                    case ">":
                        return "&gt;";
                    case "&":
                        return "&amp;";
                    case "\"":
                        return "&quot;";
                }
            })
        }
        alert(Escape("<p class=\"greeting\">Hello world!</p>"));
        //&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;
```
这个函数能够转义四种字符,  < > & ""

最后一个与模式匹配有关的方法是split(),接受两个参数,一个是分割符,一个是返回的长度。最后返回的是一个由字符串组成的数组。并且分割符也可以是RegExp对象。
```
    var colorText = "red,blue,green,yellow";
    var color1 = colorText.split(",");//["red","blue","green","yellow"]
    var color1 = colorText.split(",",2);//["red","blue"]
```

####7.localeCompare（）方法
比较的是字符串在字母表中的顺序,在之前返回1,相同为0,之后为-1。在美国是要区分大小写的,所以大写排在小写之前就成了决定性的规则,其他地区可能不尽相同。显然这样的方法是很鸡肋的。
```
    var str = "yellow";
    console.log(str.localeCompare("nidjs"));//1
    console.log(str.localeCompare("yellow"));//0
    console.log(str.localeCompare("Zoo"));-1
```

####8.formCharCode（）方法
执行的是与charCodeAt()正好相反,传入字符编码,转出字符串。

##7.单体内置对象
不依赖于宿主环境的对象,在程序执行之前就已经存在了。不必现实的实例化内置对象,因为他们已经实例化了。例如,Object、Array、String。此外还定义了两个单体内置对象,Global和Math。
###1.Global对象
所有在全局作用域定义的函数和属性,都是Global对象的属性。
####1.URI编码方法

Global对象的encodeURI()和encodeURIComponent()方法可以对URI(通用资源标识符)进行编码,有效的URI中不能包含某些字符,如空格。而这两种方法编码后可以用特殊的UTF-8编码替换所有无效的字符。

encodeURI主要用于整个URI,而encodeURIComponent会作用于URI的某一段,主要区别在于,前者只会转换空格,不会对本身属于URI的特殊字符进行编码,例如# ？ / ： 等,而后者会对URI中所有的非数字字母进行转码。例子：
```
    var uri = "http://www.wrox.com/illegal value.html#start";
    console.log(encodeURI(uri));
    http://www.wrox.com/illegal%20value.html#start
    
    console.log(encodeURIComponent(uri));
    http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.html%23start
```
与这两种方法对应的是decodeURI和decodeURIComponent。其中decodeURI只能对encodeURI编码后的字符进行解码,%23不会转换为#,因为encodeURI不会转换#,它可以将%20转换为空格。而decodeURIComponent可以解码所有特殊字符的编码。

####2.eval方法
当代码进行词法作用域的分析时,可能会做出一些性能优化,这些优化能够基于代码的词法进行静态分析预先确定所有变量和函数的定义位置,快速找到标识符。而eval方法作为一种欺骗的方式,它会修改作用域,但又无法知道具体接收到的代码。因此只能简单的假设关于标识符位置的判断都是无效的,所以会影响性能优化。
        
        词法作用域,定义在词法阶段的作用域。词法作用域是由书写代码时,将变量和块作用域写在哪里来决定的。

eval方法只接收一个参数,就是执行代码的字符串。通过该方法执行的代码,可以引用包含环境中的变量。
```
    function sayHi(){
        alert("hi");
    }
    eval(sayHi());
```
在eval中创建的任何变量或函数都不会被提升,因为在代码解析的时候他被包含在字符串中,只在eval执行时被创建。
```
    alert(str);
    eval("var str = 'hello world';");
    //str is not defined.(未声明)
```
在严格模式下,在外部访问不到eval中创建的任何变量或函数,为eval赋值也会导致错误。
####3.Global对象的属性
特殊的值,undefined、Infinity和NaN都是Global对象的属性。此外所有原生引用类型的构造函数,Object和Function也都是Global对象的属性。

        禁止给undefined、NaN、Infinity赋值。
        
####4.window对象
在Web浏览器中都是将这个全局对象作为window对象的一部分加以实现的。在全局作用域中声明的所有变量和函数都成为了window对象的属性。
```
    var global = function(){
        return this;
    }();
```

###2.Math对象
####1.min()和max()
可以接收任意多个数值参数。将数组进行排序。
```
    var arr = [29,2,333,23,6,9,3];
    Math.max.apply(null,arr);//333    
```

####2.舍入方法
Math.ceil()/Math.floor()/Math.round()[向上取整,向下取整,四舍五入]

####3.random()方法
随机返回0-1的小数