# 事件


## 1.事件流
事件就是用户或浏览器自己执行的某个动作行为。事件流描述的是从页面中接收事件的顺序。有事件冒泡流和事件捕获流。
### ①.事件冒泡
时间开始时由最具体的元素接收,然后逐级向上传播到不具体的节点(document)。
```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<div id="myDiv">Click me!</div>
</body>
</html>
```
如果点击了div,则会按照这样的顺序传播:1.div;2.body;3.html;4.document;标准浏览器都会一直冒泡到window对象。

### ②.事件捕获
事件捕获与事件冒泡正好相反,顺序为1.Document;2.html;3.body;4.div;

### ③.DOM事件流
"DOM2级事件"规定的事件流包括了三个阶段：1).事件捕获阶段2).处于目标阶段3).事件冒泡阶段。
在DOM事件流中,实际的目标在捕获阶段不会接收到事件,在捕获阶段从Document==>html==>body就停止了,下一个阶段是处于目标阶段,事件在div上发生,然后冒泡阶段发生,事件又传播回文档。

## 2.事件处理程序
### 1.HTML事件处理程序
元素支持的每种事件,都可以使用一个与事件处理程序同名的HTML特性来制定。这段特性的值应该是能执行的JS代码。例如:
```
    <input type="text" value="Click Me" onclick="alert('Clicked')">;
```
由于这个值是JS,因此不能在其中使用未经转义的HTML语法字符,例如:

        和(&)、双引号("")、小于号(<)、大于号(>);

如果要使用双引号应该改为:
```
    <input type="text" value="Click Me" onclick="alert(&quot;Clicked&quor;')">;
```
这个事件处理程序也可以包含要执行的具体动作,也可以在其他地方定义脚本。可以在独立的script元素中定义,也可以包含在外部文件中。

    这样指定的事件处理程序有一定的独到之处,首先这样会创建一个封装着元素属性值的函数,这个函数有一个局部变量event,也就是事件对象。通过event对象可以直接访问事件的名称,注意只能访问事件名称,例如:
```
    <input type="text" value="Click Me" onclick="alert(event.type)">;//click
```
    在这个函数的内部,this值等于事件的目标元素,所以可以直接访问元素的所有属性,type、value等,例如:
```
    <input type="text" value="Click Me" onclick="alert(this.value)">;
```
    关于这个动态创建的函数,另一点是它可以扩展作用域,在函数的内部可以像访问局部变量一样访问document及其元素本身的成员。原理如此：
   
```
        function(){
            with(document){
                with(this){
                    //元素属性值；
                }
            }
        }
        <input type="button" name="" value="click me"  onclick="alert(value)"><br>;//已经width语句扩展作用域链包含了this;
        <input type="button" name="" value="click me"  onclick="alert(document.documentElement.clientWidth)"><br>；
        
        
        <form action="" method="get" accept-charset="utf-8">
			<input type="password" name="password" placeholder="密码">
			<input type="button" name="" value="click me"  onclick="console.log(password.value)"><br>
		</form><br>	
```
以上的代码中可以弹出可视区的大小,说明这个动态函数的作用域链中包含document对象,而第二段代码会在控制台打出password的值,说明它能将该元素的兄弟元素放进作用域链中。注意该函数只能访问兄弟元素作用域链上的变量,如果不在一个成员下是无法访问的。

#### 缺点：
(1).如果在行间定义了事件处理程序,如果加载过程中还没读到改程序函数,HTML已经被点击,这时候可能会出现错误。为此,浏览器会代为将行间定义的事件处理程序放在try-catch块中,在抛出错误之前错误就被捕获。如下所示:
```
    <input type="button" name="" value="click me"  onclick="try{showMessage();}catch(ex){}"><br>；
```
(2).这样扩展事件处理程序的作用域链会在不同浏览器中到不不同结果。不同的JS引擎遵循的标识符解析规则不同,很可能会在访问非限定对象成员时出错。
(3).HTML与JS代码耦合度过高,如果需要更改程序很麻烦。
    
### 2.DOM0级事件处理程序
将一个函数直接赋值给一个事件处理程序。要使用JS指定事件处理程序必须取得一个要操作的对象的引用,每个元素都有自己的事件处理程序属性,这些属性全部小写,例如onclick。

使用该方法被认为是元素的方法。因此,这时候的事件处理程序是在元素的作用域中运行,也就是说this引用的是当前元素,例如：
```
    var btn = document.getElementById("btn);
    btn.onclick = function(){
        alert(this.id);//btn
    }
```
可以通过this访问元素上的所有属性和方法。这种方法添加的事件处理程序会在事件流的冒泡阶段被处理。也可以删除通过DOM0级定义的事件处理程序。
```
    btn.onclick = null;//删除事件处理程序
```


### 3.DOM2级事件处理程序
通过addEventListener()、removeEventListener()添加移除事件处理程序。该方法接收三个参数,事件名称、绑定的函数、一个布尔值。布尔值代表的是捕获(true)还是冒泡(false)阶段调用函数。
使用该方法的好处是可以为元素添加多个事件处理程序。并且通过addEventListener()添加的处理程序只能使用removeEventListener()删除,如果是匿名函数则无效。
```
    btn.addEventListener("click",funtion(){
        alert("hello world");
    },false);//注意不需要写on绑定事件！
```

### 4.IE事件处理程序
在IE中也有类似的方法,可以为一个元素添加多个事件处理程序,该方法传入两个参数,一个是事件名称,一个是事件处理程序函数。
```
    btn.attachEvent("onclick",function(){
        alert("come on");
    });//注意是onclick
    btn.attachEvent("onclick",function(){
        alert("hello world");
    });//注意此处是onclick!
```
在IE8以下的浏览器中,执行顺序是相反的,即先"hello world"再"come on"。
而要解除事件绑定则需要detachEvent()方法,同样也是不能移除匿名函数。
**最重要的一个区别**：
        
        在IE中的该方法,this指向的是window,因为事件处理程序会在全局作用域运行。
        

### 5.跨浏览器的事件处理程序
针对不同的浏览器之间需要选择是DOM2级还是IE方法还是DOM0级方法来添加事件,这个方法属于一个名叫EventUtil的对象,addHandler方法接收三个函数,事件的名称,元素,事件处理程序函数。
```
    var EventUtil = {
        addHandler : function(type,element,handler){
            if(element.addEventListener){
                element.addEventListener(type,handler,false);
            }else if(element.attachEvent){
                element.attachEvent("on" + type,handler);
            }else{
                element["on" + type] = handler;
            }
        },
        removeHandler : function(type,element,handler){
            if(element.removeEventListener){
                element.removeEventListener(type,handler);
            }else if(element.detachEvent){
                element.detachEvent("on" + type,handler);
            }else{
                element["on" + type] = null;
            }
        }
    };
    EventUtil.addHandler("click",btn,handler);
    function handler(){
    	alert("hello world")
    }
```
这样的方法在绑定和解除事件处理程序时是够用的,虽然没有考虑到IE下中this指向全局window的问题。此外还有一个问题就是通过on只能绑定一个事件处理程序。

## 3.事件对象
在触发DOM上的某个事件时,会产生一个事件对象event,它包含了所有与事件有关的信息。包括事件的类型,事件的元素及其他与特定事件相关的信息。比如鼠标导致的事件对象中会包含鼠标位置的信息。
### 1.DOM中的事件对象
兼容DOM的浏览器会将一个event对象传入事件处理程序函数中,无论是DOM 0还是DOM 1都会传入。例如：
```
    btn.onclick = function(event){
        alert(event.type);
    }
    btn.addEventListener("click",function(){
        alert(event.type);
    },false);
```
在通过HTML行间定义JS时,会自动的封装一个包含元素属性值的函数,其中就有event对象。

```
    <input type="password" onclick = "alert(event.type)";
```

| 属性/方法       | 类型   |  读/写  |   说明  |
| --------   | -----:  | :----:  | :----:  |
| bubbles     | Boolean |   只读     | 表明事件是否冒泡 |
| cancelable        |   Boolean   |   只读   |表明是否可以取消事件的默认行为 |
| currentTarget        |    Element    |  只读  |当前正在处理事件的元素 |
| defaultPrevented     | Boolean |   只读     |为true表示已经调用了preventDefault() |
| detail        |   Integer   |   只读   |与事件相关的细节信息 |
| eventPhase      |   Integer   |  只读  |调用事件处理程序的阶段:1.捕获2.处于目标3.冒泡 |
| preventDefault()        |    function    |  只读  |取消事件的默认行为,cancelable为true可以使用 |
|   stopPropagation()    | Function |   只读     |取消事件的进一步捕获或冒泡|
| target        |   Element   |   只读   |事件的目标|

在事件处理程序内部,this始终等于currentTarget,target包含的是实际的目标。如果事件处理程序在元素上,则三个值相同。
```
    var btn = document.getElementById("btn");
    btn.onclick = function(ev){
        console.log(ev.currentTarget == this);//true
        console.log(ev.target == this);//true
    }
```

如果绑定在按钮的父节点中,那么这些值是不同的：

```
    document.body.onclick = function(ev){
        console.log(ev.currentTarget == this);//true
        console.log(ev.target == this);//false
    }
```
此时点击button,target指向的是button,即事件实际的目标是button而不是document.body,由于事件的冒泡到了document.body,在那里事件才得到了处理。在通过一个函数处理多个事件时可以使用type属性：

```
    var handle = function(ev){
        switch(ev.type){
            case "click":
                alert("clicked");
                break;
                
            case "mouseover":
                ev.target.style.backgroundColor = "red";
                break;
                
            case "mouseout":
                ev.target.style.backgroundColor = "";
                break;
        }
    }
    btn.onclick = handle;
    btn.onmouseover = handle;
    btn.onmouseout = handle;
```
通过检测event对象的type属性,然后执行相应的操作。
如果想阻止浏览器的默认行为,如a标签的跳转,则可以使用preventDefault()方法：
```
    var myLink = document.getElementsByTagName("a")[0];
    myLink.onclick = function(ev){
        ev.preventDefault();
    }
```

        只有cancelable为true的事件,才可以使用该方法清除默认行为。
        
stopPropagation()方法可以阻止进一步的事件捕获或冒泡,例如：

```
    btn.onclick = function(ev){
        alert("hello");
        ev.stopPropagation();
    }
    document.body.onclick = function(){
        alert("come on");
    }
```
这样就可以阻止点击button时触发了body上的click事件函数。
事件对象的eventPhase属性可以检测事件流正处于哪个阶段,1.捕获阶段;2.目标阶段;3.冒泡阶段;例子:
```
    btn.onclick = function(ev){
        alert(ev.eventPhase);
    }
    document.body.addEventListener("click",function(ev){
        alert(ev.eventPhase);
    },true)
    document.body.onclick = function(ev){
        alert(ev.eventPhase);
    }
```

结果为1，2，3。当为2是this、target、currentTarget是相同的。

        event对象只有事件函数执行时才存在,当函数被销毁,event对象就会被销毁。
        
### 2.IE中的事件对象
 与访问DOM中的event对象方式不同,IE访问event根据指定事件处理函数决定采用哪种方式。
#### 1).如果是DOM0级方式绑定事件函数:
 
```
    btn.onclick = function(){
        var event = window.event;
        alert(event.type);
    }
```
 
 在DOM0级中,event对象作为window对象下的一个属性存在,所以通过window.event获取到event对象再执行后续的步骤。

#### 2).attachEvent方式绑定事件函数:
和DOM中的event对象相同,可以通过参数访问：
```
    btn.attachEvent("onclick",function(ev){
        alert(ev.type);
    })
```
| 属性/方法       | 类型   |  读/写  |   说明
| --------   | -----:  | :----:  |   :----:  |
 | cancelBubble  |   Boolean   |  读/写  | 默认为false,设置为true表示可以阻止冒泡行为 |
| returnValue    | Boolean |  读/写  | 默认为true,设置为false表示组织默认行为|
|   srcElement   | Element |   只读     |事件的目标(与DOM的target属性相同)|
| type        |   String   |   只读  | 被触发的事件的类型 |

事件处理函数的作用域是根据指定它的方式确定的,所以不能认为this始终等于时间目标。所以用event.srcElement比较好：
```
    btn.onclick = function(ev){
        var event = widnow.event;
        alert(event.srcElement == this);//true
    }
    btn.attachEvent("onclick",function(ev){
        alert(ev.srcElement == this);//false window此时为window
    })
```
在这个例子中,srcElement一直都为btn,而在attachEvent中,this为window。

在IE中组织默认行为的方法为returnValue,设置为false即可。

而阻止冒泡行为为cancelBubble,设置为true即可阻止冒泡,因为IE的事件流只有冒泡,所以该方法不能阻止捕获,而stopPropagation可以同时阻止捕获和冒泡行为。

```
    btn.onclcik = function(){
        alert("hellow");
        var event = window.event;
        event.cancelBubble == true;
    }
    document.body.attachEvent("onclick",function(){
        alert("come on");
    })
```

### 3.跨浏览器的事件对象
虽然DOM和IE中的event对象不同,但是基于类似性可以提出跨浏览器的方案。将之前的EventUtil增强之后得到如下的解决方案：
```
    var EventUtil = {
        addHandle : function(element,type,handler){
        
        },
        removeHandle : function(element,type,handler){
        
        },
        getEvent : function(ev){
            return ev ? ev : window.event;
        },
        getTarget : function(ev){
            return event.target || event.srcElement;
        },
        stopPropagation : function(ev){
            if(ev.stopPropagation){
                ev.stopPropagation();
            }else{
                ev.returnValue = false;
            }
        },
        preventDefault : function(ev){
            if(ev.preventDefault){
                ev.preventDefault();
            }else{
                ev.cancelBubble = true;
            }
        }
    }
    link.onclick = function(ev){
        ev = EventUtil.getEvent(ev);
        EventUtil.preventDefault(ev);
    }
```

### 4.事件类型
#### ①.UI事件
(1)load事件
当页面完全加载后(包括所有图像、JS文件、CSS文件等外部资源),就会触发window上的load事件。有两种定义onload时间函数的方式,第一种是使用如下的JS代码：
```
    EventUtil.addhandle(window,"load",function(ev){
        console.log(ev.target);
    })
```
在兼容DOM的浏览器中,event.target的值会设为document,而IE下不会为event设置srcElement属性。
第二种方式为在body元素上添加onload特性,如下所示：
```
    <body onload="alert('Loaded!')">
    
    </body>
```
一般来说在window上的任何事件都可以在body元素中通过相应的特性来指定,因为在HTML中无法访问window元素。

图像也可以触发onload事件,无论是在DOM中还是HTML的image元素。
```
    var image = document.getElementById("img");
    EventUtil.handle(image,"load",function(ev){
        ev = EventUtil.getEvent(ev);
        alert(EventUtil.getTarget(ev).src); 
    })
```

在创建新的img元素时,可以为其指定一个事件处理程序,以便图像加载完后给出提示。此时最重要的是要在指定src属性之前先指定事件。因为新图像元素不一定要添加到DOM之中才开始下载,只要有src属性就会开始下载。
```
    EventUtil.addHandle(window,"load",function(){
        var img = document.createElement("img");
        EventUtil.addHandle(img,"load",function(ev){
            var ev = EventUtil.getEvent(ev);
            alert(EventUtil.getTarget(ev).src);
        })
        document.body.appendChild(img);
        img.src="";
    });
```
还有一些元素也以非标准的方式支持load事件,在现代浏览器中,script也会触发load事件,以便确认动态加载的JS文件是否被加载完毕。如下：
```
    EventUtil.addHandle(window,"load",function(){
        var script = document.createElement("script");
        EventUtil.addHandle(script,"load",function(){
            console.log("I'm ready");
            console.log(
        })
        document.body.appendChild(script);
        script.src = "Example.js";
    });
```
与图像元素不同的一点是,script必须要设置了src并且添加到文档之后,才会开始加载文件。在大多数现代浏览器下,script的load事件中,target为script节点,而在IE9以下的浏览器中均不支持script元素上的load事件。
        
        因此此法慎用！！
        
2.resize事件
只要用户调节了窗口的高度或宽度,就会触发该事件。事件在window上出发,推荐使用JS方式,而不是body元素上的行间JS代码实现：
```
    EventUtil.addHandle(window,"resize",function(){
        console.log("I'm Changed");
    })
```
与发生在window上的事件类似,在兼容DOM的浏览器中,传入事件处理程序的event对象有一个target属性,值为document,IE8之前版本未提供任何属性。只要改变窗口大小就会触发该事件,因此最好不要在事件内部加入大量计算量的代码,导致浏览器反应变慢。

3.scroll事件
只要在垂直方向上移动了页面,就会触发该事件。在混杂模式下(不声明DOCTYPE)可以通过body元素的scrollLeft和scrollTop监控这一变化,而在标准模式下,除Safari之外的所有浏览器都使用html元素来反映这一变化：
```
    EventUtil.addHandle(window,"scroll",function(){
        if(document.compatMode == "CSS1Compat"){
            console.log(document.documentElement.scrollTop);
        }else{
            console.log(document.body.scrollTop);
        }
    })
```
与resize事件类似,改变垂直高度就会触发该事件,因此尽量使事件的处理程序代码简单。
demo：利用scroll、resize使登录框绝对居中。
```
<style>
    body{
        margin:0;
        position:relative;
        height:3000px;
    }
    #box{
        postion:absolute;
        width:800px;
        height:400px;
    }
</style>
    change();
    function change(){
        var Bwidth = box.offsetWidth;
        var Bheight = box.offsetHeight;
        var viewWidth = document.documentElement.clientWidth || document.body.clientWidth;
        var viewHeight = document.documentElement.clientHeight || document.body.clientHeight;
        
        var BscrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        box.style.left = (viewWidth - Bwidth)/2 + "px";
        box.style.top = (viewHeight - Bheight)/2 + BscrollTop + "px";
    }
    window.onscroll = change;
    window.onresize = change;
```
特别提醒：获取所有的样式(外部、内嵌式、行间）的方法：
```
    document.defaultView.getComputedStyle(element,null)
```

#### ②.焦点事件
焦点事件会在元素获得或失去焦点时触发。利用这些事件并与document.hasFocus()方法及document.activeElement属性配合。能偶获取焦点的元素就是focusable元素,获取焦点的方法：tab键、点击、focus()。
默认情况下,以下元素为focusable元素：

 - window。当页面由隐藏变为前置可见时。
 - 表单元素。input、textarea、button、option。
 - a标签、area标签(必须有href属性,为空也算)。
 - 设置tabindex属性值不为-1。
 - 设置contenteditable = "true"的元素。

有以下几个焦点事件：

 - blur：在元素失去焦点时触发,这个事件不会冒泡。所有浏览器都支持。
 - focus：在元素获得焦点时触发。这个事件不会冒泡。所有浏览器都支持。
 - focusin：在元素获得焦点时触发。与focus等价,但冒泡。
 - focusout：在元素失去焦点时触发。与blur等价,可以冒泡。
 在firefox下不支持focusin，focusout,在safari和chrome下必须通过DOM2级绑定该事件,JQuery在这上做了兼容性,所有浏览器均支持。

#### tabindex属性
1).当设置的值不为-1时,可以变为focusable元素。
2).如果设为正值（>=0),按照从小到大最后再到0,如果为负数,只能通过focus方法获取焦点。

#### ③.鼠标与滚轮事件

 - click事件。用户点击主鼠标按钮或按下回车键时触发。这一点确保了易访问性。
 - dbclick事件。用户双点击时才触发。
 - mousedown事件。鼠标按下了任意鼠标按钮时触发。
 - mouseenter事件。鼠标首次进入到元素范围内触发。这个事件不会冒泡,而且移动到后代元素中也不会触发。
 - mouseleave事件。鼠标从元素上移动到元素以外时触发。这个事件不会冒泡,而且在移动到后代元素上不会触发。
 - mouseout事件。鼠标从元素上移动到另一元素时触发,会发生冒泡。即子级会向上冒泡触发父级的同名事件。
 - mouseover事件。鼠标从元素的外部首次移入到另一元素内时触发,会发生冒泡。即子级会向上冒泡触发父级的同名事件。

除了mouseenter和mouseleave事件,其余事件均会发生冒泡,也可以被取消,取消鼠标默认事件会影响浏览器的默认行为。在一个元素上相继触发mousedown和mouseup事件才会触发click事件。检测浏览器是否支持DOM2级事件（除dbclick、mouseenter和mouseleave之外)：
```
    var isSurpported = document.implementation.hasFeature("MouseEvents","2.0");
```

如果是DOM3级事件：
```
    var isSurported = document.implementation.hasFeature("MouseEvent","3.0");
```

1).客户区坐标位置
表示鼠标指针在视口中的水平和垂直坐标。
```
    document.addEventListener("mousemove",function(ev){
        console.log("Client coordinates: " + ev.clientX + "px" + "," + ev.clientY + "px");
        }
    );
```
这个值并不包括页面滚动的距离,因此并不表示鼠标在页面上的位置。

2).页面坐标位置
表示事件在页面中的什么位置发生的。
在IE8以前的版本中不支持该属性,可以使用clientX与scrollLeft(Y/Top)配合表示。
```
    EventUtil.addHandle(window,"mousemove",function(ev){
        var ev = EventUtil.getEvent(ev);
        var pageX = ev.clientX;
        var pageY = ev.clientY;
        var Left = document.documentElement.scrollLeft || document.body.scrollLeft;
        var Top = document.documentElement.scrollTop || document.body.scrollTop;
        if(pageX == undefined){
            pageX = ev.clientX + Left;
        }
        if(pageY == undefined){
            pageY = ev.clientY + Top;
        }
        console.log("page coordinates: " +pageX+ "px" +"," + pageY + "px");
    })

```

3).屏幕坐标位置
screenX和screenY属性可以确定指针相对于整个屏幕的坐标信息。该坐标的原点在屏幕的左上角,而非浏览器下的视口(0,0)原点。

4).修改键
当鼠标在按下时键盘上的某些键的状态也会影响要采取的操作。这些修改键就是Shift、Ctrl、Meta、Alt。规定了四个属性shiftKey/ctrlKey/metaKey/altKey。这些属性包含的都是布尔值,如果相应的键被按下,则值为true。
```
    EventUtil.addHandle(window,"click",function(ev){
        var ev = EventUtil.getEvent(ev);
        var arr = new Array();
        if(ev.shiftKey){
            arr.push("Shift");
        }
        if(ev.ctrlKey){
            arr.push("Ctrl");
        }
        if(ev.metaKey){
            arr.push("Meta");
        }
        if(ev.altKey){
            arr.push("Alt");
        }
        console.log("arr :" + arr.join(","));
    })
```
注意：
        
        IE8及之前的版本不支持MetaKey属性。
        
5).相关元素
在发生mouseover和mouseout事件时,还会涉及到更多的元素。
```
    <body>
        <div id="div"></div>
    </body>
```
如果把div移出到body上,则会发生mouseout事件,失去光标的元素,即div为主目标,而body为相关元素。对于body元素来说,发生mouseover事件,获得光标的元素,即body元素为主目标,而失去目标的元素div则为相关元素。

DOM通过event对象的relatedTarget保存了相关元素,这个属性只有mouseover事件和mouseout时间才有,对于其他事件值为null。而IE不支持该属性,类似的属性为toElement和fromElement。在mouseover中的相关元素为fromElement,而mouseout的相关元素为toElement。可以将取得相关元素的方法放在跨浏览器方案中：
```
   var EventUtil = {
        //
        getRelatedElement : function(ev){
            if(ev.relatedTarget){
                return ev.relatedTarget;
            }else if(ev.fromElement){
                return ev.fromElement);
            }else if(ev.toElement){
                return ev.toElement;
            }else{
                return null;
            }
        },
        //
   }
```
6).鼠标按钮
只有主鼠标按钮被单击或回车时才会触发click事件,而mousedown或mouseup事件,则在其event对象中存在一个button属性,表示按下或释放的按钮。DOM中的button属性有三个值:0表示鼠标主键,1表示鼠标中键,2表示鼠标右键。

在IE8之前的版本中也提供了button属性,但这个属性与DOM的button1属性有很大的差异。

 - 0：表示没有按下按钮;
 - 1：表示按下了鼠标左键;
 - 2：表示按下了鼠标右键;
 - 3：表示同时按下了鼠标左右键;
 - 4：表示按下了鼠标中键;
 - 5：表示同时按下了鼠标的左键和右键;
 - 6：表示同时按下了鼠标的左键和中键;
 - 7：表示同时按下了三个按钮;

为了跨浏览器表达映射方式,将上述的1，3，5，7转换为DOM中的0,2，6转换为2,4转换为1。
```
    var EventUtil = {
        //
        getButton : function(ev){
            if(document.implementation.hasFeature("MouseEvents","2.0")){
            return ev.button;
            }else{
                switch(ev.button){//利用switch的穿透性
                    case 0:
                    case 1: 
                    case 3:
                    case 5:
                    case 7:
                        return 0;
                    case 2:
                    case 6:
                        return 2;
                    case 4:
                        return 1;
                }
            }
        }
    },
    //
```

7).鼠标滚轮事件
当鼠标滚轮与页面产生交互,页面垂直方向滚动,就会触发mousewheel事件。这个事件在任何元素上面触发,最终会冒泡到document(IE8)或window(标准浏览器,除Firefox以外)对象。与该事件对应的event有一个wheelDelta属性。当鼠标向前滑动时,wheelDelta属性值为+120的倍数,当鼠标向后滚动时,属性值为-120的倍数。

    而在Firefox下,支持的事件名为DOMMouseScroll,且该值保留在detail属性之下。鼠标滚轮向前滑动时,属性值为-3的倍数,当向后滑动时,属性值为+3的倍数。
    
如果要给出关于鼠标滚轮事件的跨浏览器解决方案,可以在EventUtil下左如下的兼容：
```
    var EventUtil = {
        //
            getWheelDelta : function(ev){
                if(ev.wheelDelta){
                    return ev.wheelDelta;
                }else{
                    return -40 * (ev.detail);
                }
            }
        //
    }
```
如果将代码放在私有作用域中,从而使新定义的函数不影响全局作用域,这里定义的函数可以作用于两个事件,如果指定的事件不存在,则处理函数静默的失败：
```
    (function(){
        function getWheel(ev){
            var ev = EventUtil.getEvent(ev);
            var delta = EventUtil.getWheelDelta(ev);
            console.log(delta);
        }
        
        EventUtil.addHandle(document,"mousewheel",getWheel);
        EventUtil.addHandle(document,"DOMMouseScroll",getWheel);
    })();
```

#### ④.键盘与文本事件
用户在使用键盘时会触发键盘事件,对键盘事件的支持主要遵循DOM0级。有三个键盘事件：

 - keydown。当用户按下键盘上的***任意键***时触发,而且如果按住不放的话会重复此事件。
 - keypress。当用户按下键盘上的***字符键***时触发,而且如果按住不放的话会重复此事件。
 - keyup。用户释放键盘上的键时触发。

只有一个文本事件textInput,在文本插入文本框之前截留文本,此时发生textInput事件。
用户按下键盘上的字符键时,首先会触发keydown事件,然后是keypress事件,最后会触发keyup事件。如果用户按住字符键不放,就会重复触发keydown和keypress事件。
如果用户按下的不是字符键,首先会触发keydown事件,然后是keyup事件。如果用户按住字符键不放,就会重复触发keydown事件。

I.键码
在发生keydown和keyup事件时,event对象的keyCode属性会包含一个代码,与键盘上特定的键对应。在FF和Opera中分号的keyCode为59,而IE、Safari、chrome返回186。

II.字符编码
按下的键会影响到屏幕文本的显示。在FF下即使按下backspace也会产生charCode属性(0),以及所按键的字符编码,而不是按下键的keyCode值。在IE8之前的版本中,则是在keyCode属性下保存该事件的字符编码。可以使用跨浏览器方案：
```
    var EventUtil = {
        //
            getCharCode : function(ev){
                if(typeof ev.charCode == "number"){
                    return ev.charCode;
                }else{
                    return ev.keyCode;
                }
            },
        //
    }
    EventUtil.addHandle(text,"keypress",function(ev){
        var ev = EventUtil.getEvent(ev);
        console.log(EventUtil.getCharCode(ev));
    })
```

III.textInput事件
DOM3定义了一个新事件,当用户在可编辑区中输入字符时,就会触发该事件。与keypress事件的区别是：

1).任何**可以获得焦点的元素**都可以触发keypress事件(点击、Tab、focus为focusable的元素）,而只有可编辑区域才能成功触发textInput事件。所以出发的范围更精准。

2).textInput必须按下能实际输入字符的键才会触发,而按下backspace也可能会触发keypress事件。

textInput事件考虑的是字符,因此event对象中还包含一个data属性,保存的就是输入的字符,输入的是啥,data属性就是啥。
```
    EventUtil.addHandle(text,"textInput",function(ev){
        var ev = EventUtil.getEvent(ev);
        console.log(ev.data);
    })
```

#### 4.HTML5事件
1).contextmenu事件
通过鼠标单击右键调出上下文菜单,由于该事件是冒泡的,所以可以为document指定一个事件处理函数,这个事件的目标是发生操作元素。在浏览器默认情况下的上下文菜单,即鼠标右击时（重新加载/另存为/复制/粘贴等）的菜单栏。也可以关闭该默认行为：
```
    EventUtil.addHandle(window,"contextmenu",function(ev){
        var ev = EventUtil.getEvent(ev);
        EventUtil.preventDefault(ev);
    })
```
如果想要给元素上添加该事件,可以这样做：
```
    EventUtil.addHandle(window,"load",function(ev){
        var div = document.get....;
        
        EventUtil.addHandle(div,"contextmenu",function(ev){
            var ev = EventUtil.getEvent(ev);
            EventUtil.preventDefault(ev);
            
            myMenu.style.left = ev.clientX + "px";
            myMenu.style.top = ev.clientY + "px";
            myMenu.style.visibility = "visible";
        })
        
        EventUtil.addHandle(document,"click",function(){
            myMenu.style.visibility = "hidden";
        })
    })
```
结构为：
```
    <div id="myDiv">
        RightClick or Ctrl+click me to get a custom context menu<br/>.Click
        anyWhere else to get th default context menu.
    </div>
    <ul id="myMenu" style="position:absolute;visibility:hidden;background-color: silver">
        <li><a href="http://www.nczonline.net">Nicholas' site</a></li>
        <li><a href="http://www.wrox.com">Wrox site</a></li>
        <li><a href="http://www.yahoo.com">Yahoo!</a></li>
    </ul>
```

2).beforeunload事件
当用户要离开当前页面时会触发的事件时,可以弹出一个告知用户是否要离开的对话框。为了显示出这个对话框,必须将ev.returnValue值设为要显示的字符串(IE、FF),同时作为函数返回(Safari、chrome)：
```
    EventUtil.addHandle(window,"beforeunload",function(ev){
        var ev = EventUtil.getEvent(ev);
        var message = "I'm really miss you if you go."
        ev.returnValue = message;
        return message;
    })
```

3).hashchange事件
这个事件是在URL的hash(url中#后的值)值变化时发生,利用hash值可以保存状态和导航信息。
```
    EventUtil.addHandle(window,"hashchange",function(ev){
        console.log("Current hash:" + location.hash);
    })
```

### 5.内存和性能
添加到页面中的事件函数数量会直接影响页面的整体运行性能。首先,每个函数都是对象,都会占用内存;内存中的对象越多,性能就越差。其次是必须指定所有事件函数导致DOM访问增多。

#### ①.事件委托
对事件函数过多的解决方式就是事件委托。利用事件冒泡可以管理某一类型的所有事件。假如需要给子集元素都添加点击事件函数,可以直接在父级身上绑定事件函数。例如：
```
    <ul id="myLinks">
        <li id="goSomewhere">Go Somewhere</li>
        <li id="doSomething">Do Somewhere</li>
        <li id="sayHi">Say hi</li>
    </ul>
    
    EventUtil.addHandle(myLinks,"click",function(ev){
        var myLink = document.getElementById("myLinks");
        var target = EventUtil.getTarget(ev);
        switch(target.id){
            case "goSomewhere" :
                document.title = "I changed the document's title";
                break;
            case "doSomething" :
                location.href = "http://www.wrox.com";
                break;
            case "sayHi" :
                alert("hi");
                break;
        }
    })
```

在这段代码中,利用了冒泡的特性,可以将li的点击事件绑定在父级元素ul身上,通过检测实际触发事件的目标target的id值,可以对应他们各自的行为,这样做显然更利于提升性能。

#### ②.移除事件处理程序
内存中不用的空事件函数也可能导致性能问题。有两种情况可能造成这样的问题。

一种情况是从文档中移除带有事件函数的元素时,例如纯DOM操作,removeChild()和replaceChild()方法,但更多的可能是使用innerHTML替换页面中的一部分。如果带有事件函数的元素被innerHTML移除了,那么添加到元素中的事件函数可能无法回收。例如：

```
    <div id="myDiv">
        <input type="button" name="" value="Click Me" id="btn">
    </div>
    
    btn.onclick = function(){
        //可以做这样的处理
        btn.onclick = null;
        myDiv.innerHTML = ...;//btn带着事件函数保存在内存中
    }
```

另一种情况就是卸载页面的时候。如果卸载前没有清理干净事件函数,他们就会滞留在内存中。每次加载完页面再卸载内存滞留的对象会越来越多。一般来说最好的办法就是卸载前先通过onunload事件处理函数移除所有事件函数。只要是通过onload事件添加的东西,最后都要通过onunload事件将他们移除。