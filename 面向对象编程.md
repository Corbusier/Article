# 面向对象编程

> 面向对象的语言都有类的概念,通过类可以创建任意多个具有相同属性和方法的对象,ECMAscript中没有类的概念,因此它的对象和其他面向对象语言的对象有所不同,这个对象里面就是一个散列表,其中就是一组组的键名键值对,这个值可以为数据或者函数.

## 理解对象

### 1. 属性类型
    
    ECMAscript中有两种属性:数据属性和访问器属性
①.数据属性
数据属性包含一个数据值的位置,可读可写,数据属性有四个描述其行为的特性:

> [[Configurable]]:表示可配置属性,能否通过删除后而重定义,能否修改属性的默认特性,或者能否把属性修改为访问器属性,直接定义在对象上的属性,该特性的默认值为true。
    
> [[Writable]]:表示能否修改属性的值,直接定义在对象上的属性,该特性的默认值为true。
    
> [[Enumerable]]:表示能否被for-in枚举,直接定义在对象上的属性,该特性的默认值为true。
    
> [[Value]]:包含这个属性的数据值,默认值为undefined。
    
要修改属性默认的特性,必须使用Object.defineProperty(),这个函数接收三个参数,属性所在的对象、属性的名字、描述符对象.其中描述符对象的属性必须是:configurale、enumerable、writable、value
```
    let person = {};
    Object.defineProperty(person,"name",{
        writable : false,
        value : "Nicholas"
    })
    person.name = "Geoge"
    alert(person.name)
```
以上代码中定义了name属性为不可写,在非严格模式下赋值操作被忽略,在严格模式下会直接抛出错误,类似的规则有不可配置的属性。
```
    var person = {};
    Object.defineProperty(person,"name",{
        configurable : false,
        value : "Nicholas"
    })
    person.name = "Geoge";
    alert(person,name);
```
在这段代码中就定义了一个name属性,并且是不可配置的,除了可以设置wriable意外,不能再设置其他任何的特性,否则会导致错误

②.访问器属性

访问器属性不包含数据值,它们包含了getter和setter函数,在读取访问器属性时,会调用getter函数,在写入访问器属性时,会调用setter函数并传入新值.访问器属性有以下四个特性:

> [[Configurable]]:能否重新配置属性,直接定义在对象上的属性,该特性的默认值为true
    
> [[Enumerable]]:能否被for-in枚举属性,直接定义在对象上的属性,该特性的默认值为true
    
> [[Set]]:读取属性时调用的函数.默认值为undefined
    
> [[Get]]:写入属性时调用的函数.默认值为undefined
    
    
访问器属性不能直接写入,必须通过Object.defineProperty()定义
```
    let book = {
        _year : 2004,
        edition:1
    }
    Object.defineProperty(book,"year",{
        set:function(){
            return this._year;
        }
        get:function(newValue){
            if(newValue>2004){
                this._year = newValue;
                edition += newValue - 2004;
            }
        }
    });
    book.year = 2005;
    alert(book.edition)//2
```
当只有Get函数时,如果再尝试写入就会发生错误,而如果只有Setter函数,则不能读取属性。

### 2.定义多个属性( Object.defineProperties() )
    
在一个对象上同时定义数据属性和访问器属性,接受两个对象参数,第一个是要添加、修改属性的对象,第二个对象的属性要和第一个对象要添加、修改的属性一一对应.
```
    var book = {};
    Object.defineProperties(book,{
        _year:{
            writable : true,
            value : 2004
        },
        edition:{
            configurable : true,
            value : 1
        },
        year:{
            get:function(){
                return this._year;
            },
            set:function(newValue){
                if(newValue > 2004){
                    this._year = newValue;
                    this.edition += newValue -2004
                }
            }
        }
    })
```

### 3.读取属性的特性( Object.getOwnPropertyDescriptor() )

> 可以取得给定属性的描述符,返回的是一个对象,接收两个参数,属性所在的对象,读取目标属性的描述符。数据属性有configurable、enumerable、value、writable,访问器属性有configurable、enumerable、set、get
    
```
    var book = {};
    Object.defineProperties(book,{
        _year:{
            value : 2017
        },
        edition:{
            value:2
        },
        year:{
            get:function(){
                return this._year;
            },
            set:function(newValue){
                if(newValue>2004){
                    this._year = newValue;
                    this.edition += newValue - 2017;
                }
            }
        }
    })
    var desciptor = Object.getOwnPropertyDescriptor(book,"_year");
    alert(desciptor.configurable);
```

以上例子说明,通过defineProperty/ies的方法定义的属性,他们的描述符默认值为false

## 创建对象 

### 1. 工厂模式
利用函数封装创建对象的细节,解决了多次重复同一个接口的缺点
```
    function createPerson(name,age,job){
        var o = new Object();
        o.name = name;
        o.age  = age;
        o.job  = job;
        o.sayName = function(){
            alert(this.name);
        };
        return o;
    }
    var person1 = createPerson("Nicholas",29,"Software Engineer");
    var person2 = createPerson("Greg",27,"Docotor");
    person1 instanceof createPerson;//false
```
虽然解决了创建多个相似对象的问题,但是却没有解决**对象识别**的问题.
### 2. 构造函数模式
    
> 构造函数可用来构建一个特定类型的对象,在运行时会自动出现在执行环境中,也可以创建自定义的构造函数,从而自定义对象类型的属性和方法。
```
    function Person(name,age,job){
        this.name = name;
        this.age  = age;
        this.job  = job;
        this.sayName = function(){
            alert(this.name);
        };
    }
    var person1 = new Person("Nicholas",29,"Software Engineer");
    var person2 = new Person("Greg",27,"Docotor");
    alert(person1 instanceof Object);//true
    alert(person1 instanceof Person);//true
    //1)没有显示的创建对象
    //2)直接将属性和方法赋给了this对象
    //3)没有return语句
```

创建自定义构造函数意味着将来可以将它的实例表示为一种特定的类型,而这正是胜过工厂模式的地方。创建Person的新实例,必须使用new操作符,调用构造函数会经历以下4个步骤:

    1)创建一个新对象;
    2)将构造函数的作用域赋给新对象;
    3)执行构造函数的代码
    4)返回新对象

 
 
#### ①.将构造函数作为函数
构造函数与其它函数唯一不同就是调用方式不同
```
    //当作构造函数使用
    var person = new Person("Nicholas",29,"Software Engineer");
    person.sayName();//Nicholas
    //作为普通函数调用
    Person("Greg",27,"Docotor");
    window.sayName();//Greg
    //在另一个对象的作用域调用
    var o = new Object();
    Person.call(o,"Kristen",25,"Nurse");
    o.sayName();
```

#### ②.构造函数的问题
每实例化一次对象,person里面的sayName函数包含的都不是同一个Function实例,这样会**导致不同的作用域链和标识符解析**,但创建Function新实例的机制仍然是相同的,然而创建两个完成同样任务的Function实例是没有必要的


### 3.原型模式

> 创建的每个函数都有prototype(原型)属性,这个属性是一个指针,指向一个对象,而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法.优点:可以将信息直接添加在原型对象中,不必再构造函数中定义对象实例的信息.
```
    function Person(){};
    Person.prototype = {
        name : "Nicholas",
        age : 29,
        job : "Software Engineer",
        sayName : function(){
            console.log(this.name);
        }
    }
    var person1 = new Person();
    var person2 = new Person();
    alert(person1.sayName == person2.sayName)//true
```
新对象的这些属性和方法是所有实例共享的,他们访问的是同一个sayName函数和同一组属性

#### 1). 理解原型对象
 创建一个函数,都会有一个prototype属性,指向函数的原型对象,原型对象会自动的获得一个constructor(构造函数)属性,这个属性是指向prototype所在函数的指针.Person.prototype.constructor ===> Person.
当调用构造函数创建一个实例后,该实例内部包含的指针(内部属性),指向构造函数的原型对象,这个指针叫[[Prototype]],这个连接存在于实例与构造函数的原型对象之间.

虽然在所有实现中都无法访问到这个内部属性([[Prototype]]),但可以通过isPrototyoeOf()方法来确定对象之间是否存在这种关系.以下例子中可以看出,实例中都有一个属性指针,指向了构造函数的原型对象.
```
    alert( Person.prototype.isPrototypeOf(person1) );//true
    alert( Person.prototype.isPrototypeOf(person2) );//true
```
ES5中有一个getPrototypeOf()方法,返回[[Prototype]]的值.这个方法可以取得对象的原型,利用原型实现继承的情况下非常重要
```
alert(Object.getPrototypeOf(person1) == Person.prototype);//true
alert(Object.getProtptypeOf(person1).name;//"Nicholas"
```

> 当代码搜索某个属性时,都会从实例上开始找对应的属性,如果没有则继续查找指针指向的原型对象上是否具有该属性或方法,代码会优先读取实例上的属性,在这之上即使是null也会直接使用,并且屏蔽原型上的同名属性,当使用delete操作符后,返回的又是原型上的属性.    
   
 hasOwnProperty()可以检测属性来自原型还是实例,只有当重写了实例上的属性时,这个方法才会返回true

```
    alert(person1.hasOwnProperty("name"));//false
    person1.name = "Greg";
    alert(person1.name);//"Greg"
    alert(person1.hasOwnProperty("name");//true(实例上拥有这个属性)
```
#### 2).原型与in操作符

hasOwnProperty()方法可以判断属性是否来自实例,存在返回true,in操作符单独使用则可以用于判断属性是否存在于实例或原型上( || ，存在一个就返回true),因此也创建一个方法判断属性是否来自于原型
①单独使用in操作符    
```
    function hasPrototypeProperty(object,name){
        return !object.hasOwnProperty(name) && (name in object); 
    }
    var a = new Person();
    alert(hasPrototypeProperty(a,"name"));//true
    a.name = "Greg";
    alert(hasPrototypeProperty(a,"name"));//false
//重写了name属性,所以原型中的name属性就找不到了,因此返回false
```
②for-in循环
    
> 循环的是能够通过对象访问的、可枚举的属性,既包括实例中的属性,也有原型中的属性。原型中标记为[[Enumerable]]为false的属性也可以被返回。在IE8以前的的版本中,这些不可枚举属性都无法for-in循环,这些属性包括了hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和valueOf().
    要获取对象上可枚举的实例属性,可以使用Object.keys()方法,该方法接收一个对象作为参数,返回可枚举属性的字符串组.1)在函数原型对象上调用可以获取到可枚举的属性.2)通过实例调用的对象使用该方法,只会获取到实例上的属性,而不是原型对象上的属性
```
    function Person(){};
    Person.prototype = {
        name : "Nicholas",
        age  : 29,
        sayName : function(){
            alert(this.name);
        }
    }
    var keys = Object.keys(Person.prototype);
    console.log(keys);//["name","age","sayName"];
    
    var p1 = new Person();
    var p1keys = Object.keys(p1);//[]
    console.log(p1keys)
    p1.name = "Bob";
    p1.age = 25;
    var p1keys = Object.keys(p1);//[]
    console.log(p1keys);//["name","age"]
```
#### 3)简洁的语法
    
> 如上所写的代码均为简写方式,即Person.prototype = {};如果是字面量的形式创建的新对象,它的constructor是指向Person的,因此需要手动的设置constructor:Person,重设constructor属性会使它的[[Enumerable]]改为true,如果需要重新定义回原生的属性(false):
```
    Object.defineProperty(Person.prototype,constrctor,{
        enumerable : false,
        value : Person
    })
```

#### 4)原型的动态性
修改原型对象可以立即从实例上反映出来,即使是先创建实例,再修改原型也可以得到这个属性。
```
    function Person(){};
    var friend = new Person();
    Person.prototype.sayHi = function(){
        alert("hi")
    }
    friend.sayHi();
```
但如果是完全的重写了这个原型对象,那么就切断了构造函数和最初原型对象之间的联系.实例中的指针([[prototype]]即_proto_属性)指向的是构造函数的原型对象而不是构造函数
```
    function Person(){};
    var friend = new Person();
    Person.prototype = {
        constructor : Person,
        sayHi : function(){
            alert("hi")
        }
    }
    friend.sayHi();
//在先创建实例,再重写原型的前提下,此时的实例仍然指向原来的构造函数的原型对象,而sayHi方法在重写的这个新原型对象上,因此无法找到sayHi方法。
```
#### 5)原生对象的原型

原生的引用类型一样可以修改其原型,随时添加方法,所有的原生类型(Object、Array、String等等),不过不建议这么做。
    
#### 6)原型模式的缺陷

①.原型模式省略了为构造模式传递初始化参数的环节,因此会导致创建的所有实例都有同样的属性值
②.更大的问题在于,当修改一个实例的属性时,结果会反映到其他的共享示例上。
```
    function Person(){};
    Person.prototype = {
        name : "Nicholas",
        age  : 27,
        friends : ["Shelby","Gobs"],
        sayName : function(){
            alert(this.name)
        }
    }
    var person1 = new Person();
    var person2 = new Person();
    person1.friends.push("Van");
    alert(person1.friends);//["Shelby","Gobs","Van"]
    alert(person2.friends);//["Shelby","Gobs","Van"]
    alert(person1.friends == person2.friends);//true
```

### 4.组合使用构造函数模式和原型模式
    
构造函数模式定义实例的属性,原型模式用于定义共享的属性和方法,每个实例都会有自己的实例属性的副本,但又同时共享着对方法的引用.因此这是一种认可度最高的方式。

```
    function Person(name,age,job){
        this.name = name;
        this.age  = age;
        this.job  = job;
        this.friends = ["Shelby","Court"]
    };
    Person.prototype = {
        constructor : Person,
        sayName : function(){
            alert(this.name)
        }
    }
    var person1 = new Person("Nocholas",27,"Software Engineer");
    var person2 = new Person("Greg",27,"Doctor");
    person1.friends.push("Van");
    alert(person1.friends);
    alert(person2.friends);
```
    
    
### 5.动态原型模式
```
    function Person(age,name,sex){
        this.age = age;
        this.name = name;
        this.sex = sex;
        if(typeof this.sayName != "function"){
            //直接修改原型对象的方法
            //Person.prototype.sayName = function(){
                //alert(this.name);
            //}
            //重写原型的方法
            Person.prototype = {
                constructor : Person,
                sayName : function(){
                    alert(this.name)
                }
            }
            return new Person(age,name,sex);
        }
    }
    var person1 = new Person(25,"Leo","male");
    var person2 = new Person(27,"Nicholas","female");
    person1.sayName();
    person2.sayName();
    console.log(typeof person1.sayName);//在方法一中为undefined,方法二function
    console.log(typeof person2.sayName);//function
```

方法一:
    
> 在第一次读取代码时,如果再实例上找不到这个sayName方法,就开始查找     原型对象上进入if条件句中,给对象添加了sayName方法(相当于初始化原型),以后创建的实例都可以共享到这个方法,不用再继续给原型上添加方法。

方法二：

> 直接重写了原型对象,根据上一节中原型的动态性,重写之后的原型与实例之间被切断了联系,第一次调用这个原型时,无法搜索找到这个方法,如果要使用这个方法,需要写明构造函数的指向,并且返回新的构造函数与新实例建立起联系。
    而关于无论哪种修改方式,都会使原型初始化,这时再添加的属性或方法,都只需检测一次if判断就可以,不需要检测添加的所有的属性和方法

### 6.寄生构造函数模式(Parasitic)
```
    function specialArray(){
        var values = new Array();    
        values.push.apply(values,arguments);
        values.toPipedString = function(){
            return join("|");
        }
        //values instanceof specialArray(false)
        return values;
    }
    var colors = new specialArray("red","blue","yellow");
    alert(colors.toPipedString());
```
该模式的原理是创建一个函数,封装创建对象的代码,然后再返回新创建的对象。
    
> 这个模式会有这样的缺陷：构造函数返回的对象,与外面的新实例对象没有什么不同,它与构造函数和构造函数的原型没有任何关系,因此不能使用instanceof测试对象类型,在可以使用其他模式的前提下,尽量少使用这种模式。

### 7.稳妥构造函数模式
    
> 这个模式下的所谓稳妥对象,指的是没有公共属性,而且其方法也不引用this的对象。该模式适合在一些安全的环境或者防止数据被其他应用程序修改时使用。和寄生构造函数模式类似,但是不在构造函数中新创建对象的实例方法上引用this,也不会使用new调用构造函数。
```
    function Person(age,name,job){
        var o = new Object();
        o.sayName = function(){
            alert(name);
        }
        console.log(o instanceof Person);//false
        return o;
    }
    var p1 = Person("Nicholas",29,"Software Engineer");
    p1.sayName();//"Nicholas"
```
这样一来,除了sayName()方法以外,没有其他的方法访问name的值,即使有其他的代码给这个对象添加新的方法或数据成员,但也不可能访问到构造函数中的原始数据。和寄生构造函数模式一样,这个创建的返回对象也和构造函数之间没有任何关系。

## 继承

> 许多的OO语言都有两种继承方式:接口继承及实现继承。接口继承只继承方法签名,而实现继承则继承实际的方法。由于函数没有签名,所以ECMAscript只支持实现继承,而实现继承主要是依靠原型链实现的。
    
### 1.原型链
> 在以下代码中,将一个原型对象直接等于一个实例,实例上有它的实例属性和原型方法,在原型对象上再加上本身的原型方法,然后再给这个原型对象的函数创建新的构造函数,在这个新的实例上调用原型对象上的方法。


```
    function SuperType(){
        this.property = true;
    }
    SuperType.prototype.getSuperValue = function(){
        return this.property;
    }
    function SubType(){
        this.subproperty = false;
    }
    //继承Supertype
    SubType.prototype = new SuperType();
    SubType.prototype.getSubValue = function(){
        return this.subproperty;
    }
    var instance = new SubType();
    alert(instance.getSuperValue());
    alert(instance.constructor == SuperType);
    
```

> SuperType上的实例属性property会继承给SubType上去,而且SubType还拥有自己的方法,它的原型指向的是SuperType的原型对象,同样,SubType的实例属性subProperty也继承给了它的实例instance,instance的内部属性([[prototype]])也通过原型链指向了SuperType。

通过以上的例子,说明了调用一个实例上的方法会经过以下的步骤:1)搜索实例。2)搜索SubType.prototype。3)搜索SuperType.prototype。正是更具这样的机制,一步步地到最后一步,直到找不到属性或方法为止。
   
#### ①.默认的原型

所有的函数的默认原型都是Object的实例,因此默认原型都会包含一个默认指针[[prototype]]指向Object.prototype,这也是所有的自定义类型都会继承toString()、valueOf()方法的根本原因。当调用instance.toString()方法时,其实是通过原型链找到了Object.prototype中的方法。

但是这个说法并不严谨,假如有Object.create()这个方法,那么相当于更改了这个默认指针的指向,现在指向的是参数里面的对象
 
#### ②.确定原型与实例的关系
 
可以通过两种方式确定原型和实例的关系,一种是instanceof()。另一个是isPrototypeOf()。
 
#### ③.定义方法的注意事项
 
> 1).如果要在SubType的原型上定义和它继承而来的原型上的同名的方法,当通过SubType的实例调用这个方法时,会屏蔽继承原型上的方法,调用重新定义的新方法,但如果通过SuperType的实例调用这个方法时,还会继续调用原来的方法。
    2).由于原型的动态性,如果要给SubType的原型上添加方法,不能使用对象字面量的方法,重写了的原型对象切断了继承的关系,现在的原型包含的是一个Object实例,而不是继承来的SuperType实例。
#### ④.原型链的问题
 
1).如果在继承而来的原型上有定义属性,那么在以后创建的所有子类型实例中都会共享这一个属性,对一个子类型实例修改这个属性后,会反映到其他的共享实例中去。
```
    function SuperType(){
        this.colors = ["black","white","yellow"];
    }
    function SubType(){};
    SubType.prototype = new SuperType();
    var p1 = new SubType();
    var p2 = new SubType();
    p1.colors.push("pink");
    alert(p1.colors);//["black","white","yellow","pink"]
    alert(p2.colors);//["black","white","yellow","pink"]
```
   
2).创建子类型的实例时,不能向超类型的构造函数传递参数。

### 2.借用构造函数
借用超类型的构造函数,为子类型的属性保存一个副本,当使用到的时候,为了防止超类型的属性重写属性,在超类型构造函数之后,添加上应该出现在子类型上定义的属性。如下:
```
    function SuperType(name){
        this.name = name;
    }
    function SubType(){
        Supertype.call(this,"Nicholas");//向超类型构造函数上传递参数
        this.age = 25;//实例属性
    }
    var person1 = new SubType();
    alert(person1.name);
    alert(person1.age);
```

优点(Advantage):

> 相对于原型链,借用构造函数模式可以在子类型的构造函数中向超类型构造函数中传递参数,在这之后再添加一个应该在子类型中定义的属性。

缺点(disadvantage):

> 对于这个方法来说,所有的属性方法都在构造函数中定义,因此不利于代码复用,并且如果在超类型构造函数的原型上定义方法,子类型也是不可见得,结果所有类型只能使用构造函数模式。
因此一般不会单独使用借用构造函数这种方式。

### 3.组合继承
将原型链和借用构造函数的技术结合到一起,使用原型链上对原型属性和方法的继承,借用构造函数实现对实例属性的继承,这样原型上的方法既能代码复用,又能保证实例属性具有个体差异。方法如下:
```
    function SuperType(name){
        //构造函数属性
        this.colors = ["yellow","black"];
        this.name = name;
    }
    SuperType.prototype.sayName = function(){
        alert(this.name);
    }
    function SubType(name,age){
        SuperType.call(this,name);
        //实例属性
        this.age = age;
    }
    SubType.prototype = new SuperType();
    //由于原型的动态性,此处一定不能重写原型,否则会造成指向的错误
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = function(){
        alert(this.age);
    }
    var person1 = new SubType("Nicholas",28);
    alert(person1.colors);
    person1.sayAge();
    person1.sayName();
    const person2 = new SubType("Greg",25);
    person2.colors.push("lemon")
    alert(person2.colors);
    person2.sayName();
    person2.sayAge();
```

以上方法中,在构造函数上定义的方法通过原型链继承给了实例,而实例属性也通过借用构造函数获取到,并且这个构造函数可以写上参数,让每一个实例既有共享的方法sayName()、构造函数的属性colors、name，又有自身的实例属性age、方法sayAge()。
### 4.原型式继承
用一个对象作为另一个对象的基础,将对象传递给这个对象函数处理一下,返回的是一个新的对象,根据需求再把返回的新对象加以修饰即可。

```
    function object(o){
        function f(){};
        f.prototype = o;
        return new f();
    }
    let person = {
        name : "Nicholas",
        friends : ["Shelby","Court"]
    }
    var anotherPerson = object(person);
    anotherPerson.name = "Greg";
    anotherPerson.friends.push("Rob");
    
    var yetAnotherPerson = object(person);
    yetAnotherPerson.name = "Linda";
    yetAnotherPerson.friends.push("Barbie");
    
    alert(person.friends);
```
在这个例子中,基础对象作为一个参数传进了object函数对象中,让这个返回的新对象以基础对象为原型,在他的原型上就包含了基础对象的所有属性,根据原型链的特性,person.friends不仅为person所有,也被anotherPerson及yetAnotherPerson共享。

ES5的Object.create( )方法,第一个参数作用相当于这个object函数,返回的是以传入参数为原型的对象,并且这个参数必须为object或null,第二个参数(可选)作用是为新对象定义额外属性的对象,它的格式与Object.defineProperties()方法的第二个参数相同。
```
    var person = {
        name : "Nicholas",
        friends : ["Shelby","Court"]
    }
    var anotherPerson = Object.create(person,{
        name : {
            value : "Greg"
        }
    });
    alert(anotherPerson.name);//Greg
```
如果需求并不是像组合继承那么的复杂,只需要一个对象和另一个对象之间保持类似的情况下,可以使用这种继承方式,但是面临的问题是,所有的包含引用类型的属性始终都会共享相应的值。

### 5.寄生式继承
创建一个仅用于封装继承过程的函数,该函数内部通过某些方式(添加方法、属性)增强对象,最后再返回这个对象。
```
    function seri(orginal){
        var clone = Object.create(orginal);
        clone.sayHi = () =>{
            alert("Hi");
        }
        //一定要返回这个对象,否则就没有result。
        return clone;
    }
    var person = {
        name : "Nicholas",
        sayName : function(){
            alert(this.name);
        }
    }
    var Another = seri(person);
    Another.sayName();
    Another.sayHi();
```
优点(advantage):
    
> 需要寄生的目标是对象而不是自定义类型和构造函数的情况下,这也是一种可选的方式。经过test,对这种方式得到的对象使用instanceof操作符进行检测,它既不属于person(isn't callable),也不属于宿主函数,如果是构造函数得到的实例对象,instanceof 构造函数为true。

缺点(disadvantage):
> 每一次调用宿主函数上的方法时,因为不能做到代码复用而降低效率,这一点与构造函数模式类似。 
    
### 6.寄生组合继承
            
当使用组合继承时,会调用两次超类型构造函数,第一次是让子类型的原型继承超类型的实例时,子类型的原型会获得超类型的属性、方法,但是这些都不一定是我们需要的。在调用子类型的构造函数创建实例时,会第二次调用超类型构造函数,这一次调用会为这个新实例添加实例属性和继承属性、方法,并且还会屏蔽它的原型上的同名属性、方法。如下:
```
    function SuperType(name){
        this.name = name;
        this.colors = ["red","white"];
        this.sayHi = () =>{
            alert("hi")
        }
    }
    function SubType(name,age){
        SuperType.call(this,name);//第二次
        this.age = age;
    }
    SubType.prototype = new SuperType();//第一次
    SubType.prototype.constructor = SubType;
    SubType.prototype.sayAge = () =>{
        alert(this.age);
    }
    var person1 = new SubType("Nicholas",27);
    var person2 = new SubType("Greg",26);
    
    //因为直接为子类型的原型重写赋值了超类型函数,因此它会继承超类型上的属性、方法,这是没有必要的。
    SubType.prototype.sayHi();//hi;
    alert(SubType.prototype.name);//undefined,没有传参所以没有值
    alert(SubType.prototype.colors);(array)
    //当创建子类型的实例时,又调用一次超类型构造函数,同样会得到超类型和子类型上的属性方法,但是它会覆盖子类型上同名的属性、方法
    person1.sayHi();
    person1.sayAge();
    alert(person1.name);//传递参数进入构造函数中,所以会有具体的值
```

根据上面的情况,发现只需要超类型函数原型即可,并不需要将其重写赋值,因此得到了寄生组合式继承这种方式。这个对象上没有任何超类型的属性和方法。
```
    function inherit(subtype,supertype){
        var prototype = Object(superType.prototype);//创建对象
        subtype.constructor = subtype;//增强对象,为创建的对象增加默认属性
        subtype.prototype = prototype;//指定对象,将这个副本
    }
```
    
优点：
    
    在于只调用一次超类型构造函数,避免了在子类型构造函数的原型上添加不必要的属性、方法,同时还能保持原型链能正常运行。